<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Compiled Tailwind CSS (built with tailwindcss CLI) -->
    <link rel="stylesheet" href="./dist/styles.css">
    <script src="./node_modules/pocketbase/dist/pocketbase.umd.js"></script>
    
    <!-- Production Scripts -->
    <!-- <link rel="stylesheet" href="https://blog.teacherjake.com/apps/scripts/tj-team-game/styles.css">
    <script src="https://blog.teacherjake.com/apps/scripts/tj-team-game/node_modules/pocketbase/dist/pocketbase.umd.js"></script> -->
</head>
<body class="text-gray-800">

    <div id="app" class="container mx-auto p-4 sm:p-6 md:p-8 max-w-7xl">
        
        <!-- Setup Screen -->
        <div id="setup-screen">
            <header class="text-center mb-8">
                <h1 class="text-4xl md:text-5xl font-bold text-gray-700">Classroom Team Game</h1>
                <p class="text-xl text-gray-500 mt-4">How many teams are playing?</p>
            </header>
            <div class="flex justify-center items-center gap-4 md:gap-8">
                <button data-teams="2" class="team-select-btn text-4xl font-bold bg-indigo-600 text-white rounded-xl shadow-lg w-32 h-32 flex items-center justify-center hover:bg-indigo-700">2</button>
                <button data-teams="3" class="team-select-btn text-4xl font-bold bg-indigo-600 text-white rounded-xl shadow-lg w-32 h-32 flex items-center justify-center hover:bg-indigo-700">3</button>
                <button data-teams="4" class="team-select-btn text-4xl font-bold bg-indigo-600 text-white rounded-xl shadow-lg w-32 h-32 flex items-center justify-center hover:bg-indigo-700">4</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Header -->
            <header class="text-center mb-6">
                <h1 class="text-4xl md:text-5xl font-bold text-gray-700">Team Game</h1>
                <p class="text-lg text-gray-500 mt-2">Remember: Each player can only speak once per round.</p>
            </header>

            <!-- Scoreboard -->
            <div id="scoreboard-container" class="mb-6">
                <!-- Scorecards will be generated here -->
            </div>
            
            <!-- Game Controls -->
            <div class="flex justify-center items-center gap-4 mb-8">
                <button id="edit-questions-btn" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75">
                    Edit Question Bank
                </button>
                <button id="new-round-btn" class="px-6 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                    New Round
                </button>
                 <button id="change-teams-btn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75">
                    Change Teams
                </button>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                <!-- Question cards will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Question Modal -->
    <div id="question-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="bg-white w-full max-w-2xl rounded-2xl shadow-2xl p-8 text-center relative transform transition-all duration-300 scale-95 opacity-0">
            <button id="close-modal-btn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div id="question-display" class="text-4xl font-semibold mb-6 min-h-[100px]"></div>
            <div id="answer-display" class="text-3xl font-bold text-green-600 mb-8 min-h-[50px] hidden"></div>
            
            <button id="reveal-answer-btn" class="w-full mb-4 px-8 py-4 bg-yellow-500 text-white font-bold rounded-lg shadow-md hover:bg-yellow-600 text-xl">
                Show Answer
            </button>

            <div id="award-points-buttons" class="grid grid-cols-2 gap-4">
                <!-- Team correct buttons will be generated here -->
            </div>
        </div>
    </div>
    
    <!-- Edit Questions Modal -->
    <div id="edit-questions-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
         <div class="bg-white w-full max-w-3xl rounded-2xl shadow-2xl p-8 relative transform transition-all duration-300 scale-95 opacity-0">
            <h3 class="text-2xl font-bold mb-4 text-center">Edit Question Bank</h3>
            <p class="text-center text-gray-500 mb-6">Add one question and its answer on each line, separated by a pipe character `|`.</p>
            <div class="flex gap-4 mb-4">
                <button id="load-pocketbase-list-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-lg shadow-md hover:bg-indigo-700">Load list</button>
                <button id="create-new-btn" class="px-4 py-2 bg-yellow-500 text-white rounded-lg shadow-md hover:bg-yellow-600">Create New</button>
                <div id="pb-auth-controls" class="flex items-center gap-2">
                    <button id="pb-login-btn" class="px-3 py-1 bg-blue-600 text-white rounded-md text-sm">Login (Google)</button>
                    <button id="pb-logout-btn" class="px-3 py-1 bg-gray-400 text-white rounded-md text-sm hidden">Logout</button>
                </div>
                <div id="pb-status" class="text-sm text-gray-500"></div>
            </div>

            <div class="mb-4">
                <select id="pb-record-select" class="w-full p-2 border border-gray-300 rounded-lg" aria-label="PocketBase records dropdown">
                    <option value="">— Select a question bank —</option>
                </select>
            </div>
            <div class="mb-4">
                <input id="pb-bank-title" class="w-full p-2 border border-gray-300 rounded-lg" placeholder="Bank title (for save to PocketBase)" />
            </div>
            <textarea id="questions-textarea" class="w-full h-64 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-400" placeholder="Example: What color is the sky? | Blue"></textarea>
            <div class="flex justify-end gap-4 mt-6">
                 <button id="cancel-edit-btn" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600">Cancel</button>
                 <button id="save-questions-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700">Open</button>
                 <button id="save-to-pb-btn" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">Save</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTS ---
            const QUESTIONS_PER_GAME = 10;
            const TEAM_COLORS = ['bg-blue-500', 'bg-red-500', 'bg-green-500', 'bg-purple-500'];

            // --- DOM ELEMENTS ---
            const setupScreen = document.getElementById('setup-screen');
            const gameScreen = document.getElementById('game-screen');
            const teamSelectButtons = document.querySelectorAll('.team-select-btn');
            const scoreboardContainer = document.getElementById('scoreboard-container');
            const gameBoard = document.getElementById('game-board');
            const questionModal = document.getElementById('question-modal');
            const questionDisplay = document.getElementById('question-display');
            const answerDisplay = document.getElementById('answer-display');
            const revealAnswerBtn = document.getElementById('reveal-answer-btn');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const awardPointsContainer = document.getElementById('award-points-buttons');
            const newRoundBtn = document.getElementById('new-round-btn');
            const editQuestionsBtn = document.getElementById('edit-questions-btn');
            const changeTeamsBtn = document.getElementById('change-teams-btn');
            const editQuestionsModal = document.getElementById('edit-questions-modal');
            const saveQuestionsBtn = document.getElementById('save-questions-btn');
            const cancelEditBtn = document.getElementById('cancel-edit-btn');
            const questionsTextarea = document.getElementById('questions-textarea');

            // --- GAME STATE ---
            let gameState = {
                teams: [], // e.g., [{ name: 'Team 1', score: 0, color: 'bg-blue-500' }]
                fullQuestionBank: [],
                questions: [],
                answeredQuestions: [],
                currentQuestionIndex: null,
            };

            // --- FULL QUESTION BANK (50 questions) ---
            const defaultQuestions = [
                // Present Simple (Do/Does)
                { question: "Make a question: She likes pizza.", answer: "Does she like pizza?" },
                { question: "Fill in the blank: ___ you like coffee?", answer: "Do" },
                { question: "Fill in the blank: Where ___ he live?", answer: "does" },
                { question: "Find the mistake: What you want?", answer: "What do you want?" },
                { question: "Make a question: They play soccer on weekends.", answer: "Do they play soccer on weekends?" },
                { question: "Find the mistake: He not like spinach.", answer: "He doesn't like spinach." },
                { question: "Find the mistake: Why she cry?", answer: "Why does she cry?" },
                { question: "Fill in the blank: When ___ the movie start?", answer: "does" },
                // Verb 'to be' (Am/Is/Are)
                { question: "Make a question: They are from Canada.", answer: "Are they from Canada?" },
                { question: "Fill in the blank: Who ___ that person?", answer: "is" },
                { question: "Fill in the blank: ___ they happy?", answer: "Are" },
                { question: "Make a question: The cat is sleeping.", answer: "Is the cat sleeping?" },
                { question: "Find the mistake: Where you are from?", answer: "Where are you from?" },
                { question: "Make a question: It is cold outside.", answer: "Is it cold outside?" },
                { question: "Find the mistake: Why they are sad?", answer: "Why are they sad?" },
                { question: "Fill in the blank: What ___ your name?", answer: "is" },
                // Past Simple (Did)
                { question: "Make a question: You went to the park.", answer: "Did you go to the park?" },
                { question: "Find the mistake: You saw the movie?", answer: "Did you see the movie?" },
                { question: "Fill in the blank: ___ she call you yesterday?", answer: "Did" },
                { question: "Make a question: He finished his homework.", answer: "Did he finish his homework?" },
                { question: "Find the mistake: What time you did get home?", answer: "What time did you get home?" },
                { question: "Fill in the blank: Where ___ they go on vacation?", answer: "did" },
                { question: "Make a question: They ate all the cookies.", answer: "Did they eat all the cookies?" },
                { question: "Make a question: She bought a new car.", answer: "Did she buy a new car?" },
                // Verb 'to be' Past (Was/Were)
                { question: "Make a question: He was late yesterday.", answer: "Was he late yesterday?" },
                { question: "Fill in the blank: ___ they at the party?", answer: "Were" },
                { question: "Find the mistake: Where you were last night?", answer: "Where were you last night?" },
                { question: "Make a question: The shops were open.", answer: "Were the shops open?" },
                { question: "Fill in the blank: ___ it raining this morning?", answer: "Was" },
                { question: "Make a question: She was a doctor.", answer: "Was she a doctor?" },
                { question: "Find the mistake: He were tired?", answer: "Was he tired?" },
                { question: "Fill in the blank: Why ___ you angry?", answer: "were" },
                // Modals & Mixed (Can/Will/Have)
                { question: "Make a question: He can swim fast.", answer: "Can he swim fast?" },
                { question: "Find the mistake: Is he have a brother?", answer: "Does he have a brother?" },
                { question: "Fill in the blank: ___ you help me, please?", answer: "Can / Will" },
                { question: "Make a question: You have seen this movie.", answer: "Have you seen this movie?" },
                { question: "Find the mistake: Where they will go?", answer: "Where will they go?" },
                { question: "Find the mistake: You can to speak English?", answer: "Can you speak English?" },
                // Who/What Subject Questions (No auxiliary 'do/does/did')
                { question: "Ask about the subject: 'She' likes pizza.", answer: "Who likes pizza?" },
                { question: "Ask about the subject: 'The cat' is sleeping.", answer: "What is sleeping?" },
                { question: "Ask about the subject: 'They' went to the park.", answer: "Who went to the park?" },
                { question: "Ask about the subject: 'He' can swim fast.", answer: "Who can swim fast?" },
                { question: "Ask about the subject: 'The movie' starts at 8.", answer: "What starts at 8?" },
                // Who/What Object Questions (Needs auxiliary 'do/does/did')
                { question: "Ask about the object: She likes 'pizza'.", answer: "What does she like?" },
                { question: "Ask about the object: He finished 'his homework'.", answer: "What did he finish?" },
                { question: "Ask about the object: They ate 'the cookies'.", answer: "What did they eat?" },
                { question: "Ask about the object: She bought 'a new car'.", answer: "What did she buy?" },
                { question: "Ask about the object: She called 'him' yesterday.", answer: "Who did she call yesterday?" },
            ];

            // --- FUNCTIONS ---

            /**
             * Starts the game with the selected number of teams.
             * @param {number} teamCount - The number of teams (2, 3, or 4).
             */
            function startGame(teamCount) {
                // 1. Initialize teams
                gameState.teams = [];
                for (let i = 0; i < teamCount; i++) {
                    gameState.teams.push({
                        name: `Team ${i + 1}`,
                        score: 0,
                        color: TEAM_COLORS[i]
                    });
                }
                
                // 2. Adjust scoreboard layout for centering
                scoreboardContainer.className = "grid gap-4 mb-6"; // Reset and apply base classes
                if (teamCount === 2) {
                    scoreboardContainer.classList.add('grid-cols-2', 'max-w-2xl', 'mx-auto');
                } else if (teamCount === 3) {
                    scoreboardContainer.classList.add('grid-cols-3', 'max-w-4xl', 'mx-auto');
                } else { // teamCount is 4
                    scoreboardContainer.classList.add('grid-cols-2', 'md:grid-cols-4');
                }

                // 3. Switch screens
                setupScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');

                // 4. Render initial game state
                renderScoreboard();
                startNewRound();
            }

            /**
             * Renders the scoreboard based on the number of teams.
             */
            function renderScoreboard() {
                scoreboardContainer.innerHTML = '';
                gameState.teams.forEach((team, index) => {
                    const card = document.createElement('div');
                    card.className = `${team.color} text-white p-6 rounded-xl shadow-lg text-center`;
                    card.innerHTML = `
                        <h2 class="text-3xl font-bold">${team.name}</h2>
                        <p id="team-${index}-score" class="text-6xl font-bold mt-2">0</p>
                    `;
                    scoreboardContainer.appendChild(card);
                });
            }
            
            /**
             * Updates the scoreboard display with current scores.
             */
            function updateScoreboard() {
                gameState.teams.forEach((team, index) => {
                    const scoreEl = document.getElementById(`team-${index}-score`);
                    if (scoreEl) {
                        scoreEl.textContent = team.score;
                    }
                });
            }

            /**
             * Resets scores and the board for a new round with new questions.
             */
            function startNewRound() {
                gameState.teams.forEach(team => team.score = 0);
                gameState.answeredQuestions = [];
                gameState.currentQuestionIndex = null;
                selectRandomQuestions();
                updateScoreboard();
                renderGameBoard();
            }

            /**
             * Shuffles an array in place.
             * @param {Array} array The array to shuffle.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            /**
             * Loads the full question bank into memory. This intentionally does NOT use localStorage.
             */
            function loadFullQuestionBank() {
                gameState.fullQuestionBank = [...defaultQuestions];
            }

            /**
             * Selects a random subset of questions for the current game.
             */
            function selectRandomQuestions() {
                shuffleArray(gameState.fullQuestionBank);
                gameState.questions = gameState.fullQuestionBank.slice(0, QUESTIONS_PER_GAME);
            }

            /**
             * Renders the game board with question cards.
             */
            function renderGameBoard() {
                gameBoard.innerHTML = '';
                gameState.questions.forEach((_, index) => {
                    const card = document.createElement('div');
                    card.className = 'card bg-white p-4 rounded-xl shadow-md flex items-center justify-center cursor-pointer aspect-square';
                    
                    if (gameState.answeredQuestions.includes(index)) {
                         card.classList.add('disabled-card');
                    } else {
                        card.addEventListener('click', () => showQuestion(index));
                    }

                    const cardText = document.createElement('span');
                    cardText.className = 'text-5xl font-bold text-indigo-500';
                    cardText.textContent = index + 1;
                    card.appendChild(cardText);
                    gameBoard.appendChild(card);
                });
            }

            /**
             * Shows the question modal and generates award buttons.
             * @param {number} index - The index of the question to show.
             */
            function showQuestion(index) {
                if (gameState.answeredQuestions.includes(index)) return;
                
                gameState.currentQuestionIndex = index;
                const qa = gameState.questions[index];
                questionDisplay.textContent = qa.question;
                answerDisplay.textContent = qa.answer;
                answerDisplay.classList.add('hidden');
                revealAnswerBtn.classList.remove('hidden');

                // Generate award buttons dynamically
                awardPointsContainer.innerHTML = '';
                gameState.teams.forEach((team, teamIndex) => {
                    const button = document.createElement('button');
                    const hoverColor = team.color.replace('-500', '-600');
                    button.className = `px-8 py-4 ${team.color} text-white font-bold rounded-lg shadow-md hover:${hoverColor} text-xl`;
                    button.textContent = `${team.name} Correct!`;
                    button.addEventListener('click', () => awardPoints(teamIndex));
                    awardPointsContainer.appendChild(button);
                });

                questionModal.classList.remove('hidden');
                setTimeout(() => {
                    questionModal.querySelector('div').classList.remove('scale-95', 'opacity-0');
                }, 10);
            }
            
            /**
             * Closes the question modal.
             */
            function closeModal() {
                 questionModal.querySelector('div').classList.add('scale-95', 'opacity-0');
                 setTimeout(() => {
                    questionModal.classList.add('hidden');
                 }, 300);
            }

            /**
             * Awards points to a team and closes the modal.
             * @param {number} teamIndex - The index of the team to award points to.
             */
            function awardPoints(teamIndex) {
                gameState.teams[teamIndex].score += 10;
                
                if (gameState.currentQuestionIndex !== null) {
                    gameState.answeredQuestions.push(gameState.currentQuestionIndex);
                }

                updateScoreboard();
                renderGameBoard();
                closeModal();
            }
            
            /**
             * Opens the edit questions modal.
             */
            function openEditModal() {
                const questionsText = gameState.fullQuestionBank.map(q => `${q.question} | ${q.answer}`).join('\n');
                questionsTextarea.value = questionsText;
                editQuestionsModal.classList.remove('hidden');
                setTimeout(() => {
                    editQuestionsModal.querySelector('div').classList.remove('scale-95', 'opacity-0');
                }, 10);
            }

            /**
             * Closes the edit questions modal.
             */
            function closeEditModal() {
                editQuestionsModal.querySelector('div').classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    editQuestionsModal.classList.add('hidden');
                }, 300);
            }

            /**
             * Saves new questions from the textarea to the full bank.
             */
            function saveQuestions() {
                const lines = questionsTextarea.value.split('\n').filter(line => line.trim() !== '');
                const newQuestions = lines.map(line => {
                    const parts = line.split('|');
                    if (parts.length === 2) {
                        return { question: parts[0].trim(), answer: parts[1].trim() };
                    }
                    return null;
                }).filter(q => q !== null);

                if (newQuestions.length > 0) {
                    gameState.fullQuestionBank = newQuestions;
                    startNewRound();
                    closeEditModal();
                } else {
                    questionsTextarea.classList.add('border-red-500', 'ring-red-500');
                    setTimeout(() => {
                         questionsTextarea.classList.remove('border-red-500', 'ring-red-500');
                    }, 2000);
                }
            }

            // --- EVENT LISTENERS ---
            teamSelectButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const teamCount = parseInt(button.dataset.teams, 10);
                    startGame(teamCount);
                });
            });

            revealAnswerBtn.addEventListener('click', () => {
                answerDisplay.classList.remove('hidden');
                revealAnswerBtn.classList.add('hidden');
            });

            closeModalBtn.addEventListener('click', closeModal);
            newRoundBtn.addEventListener('click', startNewRound);
            changeTeamsBtn.addEventListener('click', () => {
                window.location.reload();
            });
            
            editQuestionsBtn.addEventListener('click', openEditModal);
            saveQuestionsBtn.addEventListener('click', saveQuestions);
            cancelEditBtn.addEventListener('click', closeEditModal);

            // --- POCKETBASE INTEGRATION ---
            const pbStatus = document.getElementById('pb-status');
            const loadListBtn = document.getElementById('load-pocketbase-list-btn');
            const pbRecordSelect = document.getElementById('pb-record-select');
            const createNewBtn = document.getElementById('create-new-btn');
            const POCKETBASE_URL = 'https://blog.teacherjake.com';
            const pbLoginBtn = document.getElementById('pb-login-btn');
            const pbLogoutBtn = document.getElementById('pb-logout-btn');
            const pbBankTitle = document.getElementById('pb-bank-title');
            const saveToPbBtn = document.getElementById('save-to-pb-btn');

            // PocketBase client instance
            const pb = new PocketBase(POCKETBASE_URL);

            // Tracks whether the user explicitly wants to create a new record
            let creatingNew = false;

            function updateAuthUI() {
                if (pb.authStore.isValid) {
                    pbLoginBtn.classList.add('hidden');
                    pbLogoutBtn.classList.remove('hidden');
                    pbStatus.textContent = `Logged in as ${pb.authStore.record?.email || pb.authStore.record?.id}`;
                } else {
                    pbLoginBtn.classList.remove('hidden');
                    pbLogoutBtn.classList.add('hidden');
                    pbStatus.textContent = '';
                }
            }

            // Try to restore authStore from storage automatically
            pb.authStore.onChange(() => updateAuthUI());
            updateAuthUI();

            // OAuth2 login (Google) — will redirect to PocketBase oauth endpoint
            pbLoginBtn.addEventListener('click', async () => {
                try {
                    // This uses redirect flow — ensure redirect URL is configured in PocketBase
                    await pb.collection('users').authWithOAuth2({ provider: 'google' });
                } catch (err) {
                    console.error(err);
                    pbStatus.textContent = 'Login failed: ' + (err.message || err);
                }
            });

            pbLogoutBtn.addEventListener('click', () => {
                pb.authStore.clear();
                updateAuthUI();
            });

            /**
             * Save current textarea as a teamGames record in PocketBase.
             * If a record is selected in the dropdown, update it; otherwise create a new record.
             */
            async function saveToPocketBase() {
                const title = pbBankTitle.value.trim() || 'Untitled';
                const lines = questionsTextarea.value.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                const parsed = lines.map(line => {
                    const parts = line.split('|');
                    if (parts.length >= 2) return { question: parts[0].trim(), answer: parts.slice(1).join('|').trim() };
                    return null;
                }).filter(x => x !== null);

                if (parsed.length === 0) {
                    pbStatus.textContent = 'No valid questions to save.';
                    return;
                }

                try {
                    // Build payload. Store questionbank as JSON string (array of objects)
                    const payload = { title, questionbank: JSON.stringify(parsed) };

                    const collection = 'teamGames';
                    const selectedId = pbRecordSelect.value;

                    let res;
                    // If creatingNew flag is set, always create. Otherwise, update selected record if any.
                    if (creatingNew) {
                        res = await pb.collection(collection).create(payload);
                        pbStatus.textContent = 'Created new question bank.';
                        creatingNew = false; // reset
                    } else if (selectedId) {
                        res = await pb.collection(collection).update(selectedId, payload);
                        pbStatus.textContent = 'Updated existing question bank.';
                    } else {
                        // No selection and not explicitly creating — require user to click Create New first
                        pbStatus.textContent = 'Select a record or click Create New to create one.';
                        return;
                    }

                    // Refresh list and select the saved record
                    await loadPocketBaseList();
                    if (res && res.id) {
                        pbRecordSelect.value = res.id;
                    }
                } catch (err) {
                    console.error(err);
                    pbStatus.textContent = 'Error saving to PocketBase: ' + (err.message || err);
                }
            }

            saveToPbBtn.addEventListener('click', saveToPocketBase);

            /**
             * Tries to fetch a PocketBase record and populate the questions textarea.
             * Expects the PocketBase record to have a `questionbank` field which may be:
             * - a string with lines 'Question | Answer' per line
             * - a JSON array of objects [{ question, answer }, ...]
             */
            async function fetchPocketBaseRecord(recordId) {
                const baseUrl = POCKETBASE_URL;

                if (!recordId) {
                    pbStatus.textContent = 'No record selected.';
                    return;
                }

                try {
                    pbStatus.textContent = 'Connecting...';
                    const pb = new PocketBase(baseUrl);

                    // Fetch from the teamGames collection using the provided recordId
                    const collection = 'teamGames';
                    const record = await pb.collection(collection).getOne(recordId);

                    if (!record) {
                        pbStatus.textContent = 'Record not found.';
                        return;
                    }

                    pbStatus.textContent = 'Record fetched. Parsing...';
                    const qb = record.questionbank;
                    let parsed = [];

                    if (!qb) {
                        pbStatus.textContent = 'Record has no `questionbank` field.';
                        return;
                    }

                    // If it's an array already
                    if (Array.isArray(qb)) {
                        parsed = qb.filter(item => item && item.question && item.answer).map(item => ({ question: item.question, answer: item.answer }));
                    } else if (typeof qb === 'string') {
                        // Try to parse as JSON
                        try {
                            const maybe = JSON.parse(qb);
                            if (Array.isArray(maybe)) {
                                parsed = maybe.filter(item => item && item.question && item.answer).map(item => ({ question: item.question, answer: item.answer }));
                            }
                        } catch (e) {
                            // Not JSON, fall back to newline-parsing
                        }

                        if (parsed.length === 0) {
                            // Split by newlines and expect 'question | answer'
                            const lines = qb.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                            parsed = lines.map(line => {
                                const parts = line.split('|');
                                if (parts.length >= 2) {
                                    return { question: parts[0].trim(), answer: parts.slice(1).join('|').trim() };
                                }
                                return null;
                            }).filter(x => x !== null);
                        }
                    } else if (typeof qb === 'object') {
                        // Could be an object with nested data
                        if (Array.isArray(qb.items)) {
                            parsed = qb.items.filter(item => item && item.question && item.answer).map(item => ({ question: item.question, answer: item.answer }));
                        }
                    }

                    if (parsed.length === 0) {
                        pbStatus.textContent = 'No valid questions parsed from `questionbank`.';
                        return;
                    }

                    // Convert to textarea format and set, and populate the title field
                    const text = parsed.map(q => `${q.question} | ${q.answer}`).join('\n');
                    questionsTextarea.value = text;
                    pbBankTitle.value = record.title || '';
                    pbStatus.textContent = `Loaded ${parsed.length} questions.`;

                    // Update in-memory question bank (do not persist to localStorage)
                    gameState.fullQuestionBank = parsed;
                    creatingNew = false; // loaded an existing record
                } catch (err) {
                    console.error(err);
                    pbStatus.textContent = 'Error fetching record: ' + (err.message || err);
                }
            }

            // fetchPbBtn removed; selection of dropdown will trigger fetch

            /**
             * Loads the list of records from the `teamGames` collection and populates the dropdown.
             */
            async function loadPocketBaseList() {
                const baseUrl = POCKETBASE_URL;
                pbStatus.textContent = 'Loading list...';

                try {
                    const pb = new PocketBase(baseUrl);
                    // Get all records (paginated). We'll request a large perPage up to 200 to simplify.
                    const collection = 'teamGames';
                    const res = await pb.collection(collection).getFullList(200, { sort: '-created' });

                    // Clear and populate (sorted alphabetically by title)
                    pbRecordSelect.innerHTML = '<option value="">— Select a question bank —</option>';
                    res.sort((a, b) => {
                        const aTitle = (a.title || a.name || (a.questionbank && (typeof a.questionbank === 'string' ? a.questionbank.slice(0,40) : '')) || '').toString().toLowerCase();
                        const bTitle = (b.title || b.name || (b.questionbank && (typeof b.questionbank === 'string' ? b.questionbank.slice(0,40) : '')) || '').toString().toLowerCase();
                        return aTitle.localeCompare(bTitle);
                    }).forEach(rec => {
                        const title = rec.title || rec.name || (rec.questionbank && (typeof rec.questionbank === 'string' ? rec.questionbank.slice(0,40) : 'Question Bank'));
                        const opt = document.createElement('option');
                        opt.value = rec.id;
                        opt.textContent = title;
                        pbRecordSelect.appendChild(opt);
                    });

                    pbStatus.textContent = `Loaded ${res.length} records.`;
                } catch (err) {
                    console.error(err);
                    pbStatus.textContent = 'Error loading list: ' + (err.message || err);
                }
            }

            loadListBtn.addEventListener('click', loadPocketBaseList);

            createNewBtn.addEventListener('click', () => {
                // Clear selection and title/textarea for a fresh entry
                pbRecordSelect.value = '';
                pbBankTitle.value = '';
                questionsTextarea.value = '';
                creatingNew = true;
                pbStatus.textContent = 'Creating new question bank. Enter title and questions, then click Save.';
            });

            pbRecordSelect.addEventListener('change', (e) => {
                const id = e.target.value;
                if (id) {
                    // Auto-fetch the selected record
                    fetchPocketBaseRecord(id);
                }
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (!questionModal.classList.contains('hidden')) closeModal();
                    if (!editQuestionsModal.classList.contains('hidden')) closeEditModal();
                }
            });

            // --- INITIALIZE ---
            loadFullQuestionBank();
         });
     </script>
 </body>
 </html>
